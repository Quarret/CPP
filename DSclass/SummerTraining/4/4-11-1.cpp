 #include<string>
 #include<iostream>
 #include<sstream>
 #include<stack>
 #include<cmath>
 using namespace std;
 
 
 /*
 单纯递归会超时  要用动态规划~ 保存已经算好的数据 
 后一天的情况会跟前一天情况相关联！
 */
 
 int a[110];
 int n;
 int dp[110][3];  //0休息，1编程，2健身    i表示时间（从1开始）,j表示这天干啥 ,
 				  //dp[i][j]表示i天做j事情所得到的休息天数 
 int main(){
 	cin>>n;
 	for(int i=1;i<=n;i++) cin>>a[i];  //下标从1开始，第一天 
 	
 	for(int i;i<=n;i++)
 		for(int j=0;j<3;j++) 
 			dp[i][j]=10000;  //初始化一个大数字，为的是后面选取最小休息天方便 
 	
 	//动态规划要有初始值
 	 if(a[1]==1) dp[1][1]=0;  //第一天编程，第一天休息0天 
 	 if(a[1]==2) dp[1][2]=0;  //第一天健身，第一天休息0天 
 	 if(a[1]==3) {
	 	dp[1][1]=0;
	    dp[1][2]=0; 
	  } 
 	 //今天做或者不做某件事儿，dp[1][j]中会有一个或两个改变 ，其它仍是10000极大值 
 	 dp[1][0]=1;  //第一天如果休息，则休息天数+1 
 	 
	for(int i=2;i<=n;i++){    //从第二天开始 
				
			if(a[i]==1){            //今天想编程的话，前一天只能是健身或者休息，最小休息天数不变 
				dp[i][1]=min(dp[i-1][0],dp[i-1][2]);
			}else if(a[i]==2){      //今天想健身的话，前一天只能是编程或者休息，最小休息天数不变 
				dp[i][2]=min(dp[i-1][0],dp[i-1][1]);
			}else if(a[i]==3){
				dp[i][1]=min(dp[i-1][0],dp[i-1][2]);
				dp[i][2]=min(dp[i-1][0],dp[i-1][1]);
			}	
			dp[i][0]= 1 + min(dp[i-1][0],min(dp[i-1][1],dp[i-1][2]));  //如果今天选择休息，那么天数+1 
	} 
	
 	//在最后一天中，找出最小休息天数	
	cout<<min(dp[n][0],min(dp[n][1],dp[n][2]))<<'\n';  
 }